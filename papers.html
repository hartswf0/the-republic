<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>PAPERS — Research Document Management</title>
<style>
:root{
  --bg:#0a0a0a;--bg2:#111;--panel:#161616;
  --fg:#f0f0f0;--dim:#a0a0a0;--muted:#606060;
  --accent:#d4a853;--accent2:#e8c47a;
  --prompt:#60a5fa;--complete:#34d399;--draft:#fbbf24;
  --border:#2a2a2a;--border2:#3a3a3a;
  --success:#22c55e;--error:#ef4444;
  --shadow:rgba(0,0,0,.4);
}
[data-theme="light"]{
  --bg:#faf9f7;--bg2:#f0efec;--panel:#fff;
  --fg:#1a1a1a;--dim:#4a4a4a;--muted:#888;
  --accent:#8b5a2b;--accent2:#a67c52;
  --border:#e0ddd8;--border2:#d0cdc8;
  --shadow:rgba(0,0,0,.1);
}
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Courier New',monospace;background:var(--bg);color:var(--fg);overflow:hidden;font-size:13px;line-height:1.75}

.header{position:fixed;top:0;left:0;right:0;height:44px;background:var(--panel);border-bottom:1px solid var(--border);display:flex;align-items:center;padding:0 12px;z-index:100;gap:12px}
.logo{font-weight:600;font-size:11px;color:var(--accent);display:flex;align-items:center;gap:6px}
.logo svg{width:16px;height:16px}
.title{font-size:10px;color:var(--dim);letter-spacing:.05em}
.search-bar{flex:1;max-width:300px;position:relative}
.search-bar input{width:100%;padding:6px 10px 6px 28px;background:var(--bg);border:1px solid var(--border);border-radius:4px;color:var(--fg);font:inherit;font-size:10px}
.search-bar input:focus{outline:none;border-color:var(--accent)}
.search-bar svg{position:absolute;left:8px;top:50%;transform:translateY(-50%);width:12px;height:12px;color:var(--muted)}
.header-actions{margin-left:auto;display:flex;gap:4px}
.icon-btn{width:32px;height:32px;background:var(--bg);border:1px solid var(--border);color:var(--muted);cursor:pointer;border-radius:4px;display:flex;align-items:center;justify-content:center}
.icon-btn:hover{border-color:var(--accent);color:var(--accent)}
.icon-btn svg{width:14px;height:14px}

.scroll-container{display:flex;height:calc(100vh - 44px);margin-top:44px;overflow-x:auto;overflow-y:hidden;scroll-behavior:smooth}
.scroll-container::-webkit-scrollbar{height:6px}
.scroll-container::-webkit-scrollbar-track{background:var(--bg2)}
.scroll-container::-webkit-scrollbar-thumb{background:var(--border2);border-radius:3px}

.column{min-width:340px;width:340px;height:100%;border-right:1px solid var(--border);background:var(--bg);display:flex;flex-direction:column;flex-shrink:0}
.column.wide{min-width:500px;width:500px}
.column.content-col{min-width:600px;width:600px;flex:1}
.column-header{height:44px;display:flex;align-items:center;justify-content:space-between;padding:0 12px;border-bottom:1px solid var(--border);background:var(--panel);flex-shrink:0}
.column-info{display:flex;align-items:center;gap:8px;overflow:hidden}
.column-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
.column-title{font-size:10px;letter-spacing:.03em;color:var(--fg);font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.column-badge{font-size:8px;color:var(--muted);background:var(--bg);padding:2px 6px;border-radius:3px}
.column-actions{display:flex;gap:2px}
.col-btn{width:24px;height:24px;background:transparent;border:1px solid transparent;color:var(--muted);cursor:pointer;border-radius:3px;display:flex;align-items:center;justify-content:center}
.col-btn:hover{border-color:var(--border);color:var(--accent);background:var(--bg)}
.col-btn svg{width:12px;height:12px}

.column-content{flex:1;overflow-y:auto;padding:12px}
.column-content::-webkit-scrollbar{width:4px}
.column-content::-webkit-scrollbar-thumb{background:var(--border2);border-radius:2px}

/* Paper List */
.paper-list{display:flex;flex-direction:column;gap:6px}
.paper-item{padding:10px 12px;background:var(--panel);border:1px solid var(--border);border-radius:6px;cursor:pointer;transition:all .15s}
.paper-item:hover{border-color:var(--accent);background:var(--bg2)}
.paper-item.active{border-color:var(--accent);background:rgba(212,168,83,.1)}
.paper-title{font-size:10px;font-weight:600;color:var(--fg);margin-bottom:4px;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}
.paper-meta{font-size:9px;color:var(--muted);display:flex;align-items:center;gap:8px}
.paper-type{font-size:8px;padding:2px 6px;border-radius:3px;text-transform:uppercase;letter-spacing:.03em}
.paper-type.prompt{background:var(--prompt);color:#000}
.paper-type.complete{background:var(--complete);color:#000}
.paper-type.draft{background:var(--draft);color:#000}

/* Chain Group */
.chain-group{margin-bottom:16px;padding:12px;background:var(--panel);border:1px solid var(--border);border-radius:6px}
.chain-header{font-size:9px;color:var(--accent);letter-spacing:.05em;margin-bottom:8px;font-weight:600}
.chain-arrow{color:var(--muted);font-size:9px;padding:4px 0;text-align:center}
.chain-papers{display:flex;flex-direction:column;gap:4px}
.chain-papers .paper-item{background:var(--bg)}

/* Content Display */
.paper-content{padding:20px;max-width:none}
.paper-content h1{font-size:16px;color:var(--accent);margin-bottom:8px;line-height:1.4;font-weight:600}
.paper-content h2{font-size:13px;color:var(--accent2);margin:20px 0 10px;padding-bottom:4px;border-bottom:1px solid var(--border)}
.paper-content h3{font-size:12px;color:var(--fg);margin:14px 0 8px}
.paper-content p{margin-bottom:12px;text-align:justify;color:var(--fg)}
.paper-content ul,.paper-content ol{margin:12px 0 12px 20px}
.paper-content li{margin-bottom:6px}
.paper-content blockquote{border-left:2px solid var(--accent);padding-left:12px;margin:14px 0;color:var(--dim);font-style:italic}
.paper-content code{background:var(--bg2);padding:2px 6px;border-radius:3px;font-size:11px}
.paper-content pre{background:var(--bg2);padding:14px;border-radius:4px;overflow-x:auto;margin:14px 0;border:1px solid var(--border)}
.paper-content table{width:100%;border-collapse:collapse;margin:14px 0;font-size:11px}
.paper-content th,.paper-content td{border:1px solid var(--border);padding:8px;text-align:left}
.paper-content th{background:var(--bg2)}

/* Citations */
.citation{color:var(--prompt);cursor:pointer;font-size:10px;vertical-align:super}
.citation:hover{text-decoration:underline}

/* References Panel */
.ref-panel{display:flex;flex-direction:column}
.ref-item{padding:10px 12px;border-bottom:1px solid var(--border);font-size:10px}
.ref-item:last-child{border-bottom:none}
.ref-num{color:var(--accent);font-weight:600;margin-right:6px}
.ref-title{color:var(--fg);display:block;margin:4px 0}
.ref-url{color:var(--muted);font-size:9px;word-break:break-all}
.ref-url a{color:var(--prompt)}

/* Empty State */
.empty-state{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;color:var(--muted);text-align:center;padding:24px}
.empty-state-icon{font-size:11px;margin-bottom:12px;color:var(--accent);letter-spacing:.1em}

/* Manifest List */
.manifest-list{margin-top:16px;text-align:left}
.manifest-item{padding:10px 12px;background:var(--panel);border:1px solid var(--border);border-radius:6px;margin-bottom:6px;display:flex;justify-content:space-between;align-items:center}
.manifest-item:hover{border-color:var(--accent)}
.manifest-title{font-size:10px;color:var(--fg);font-weight:600}
.manifest-status{font-size:8px;color:var(--muted)}
.manifest-btn{padding:4px 10px;background:var(--bg);border:1px solid var(--border);color:var(--fg);font:inherit;font-size:9px;cursor:pointer;border-radius:4px}
.manifest-btn:hover{border-color:var(--accent);color:var(--accent)}
.manifest-btn.primary{background:var(--accent);border-color:var(--accent);color:#000}

/* Stats Bar */
.stats-bar{padding:8px 12px;border-top:1px solid var(--border);background:var(--panel);display:flex;gap:16px;font-size:9px}
.stat{display:flex;gap:4px}
.stat-label{color:var(--muted)}
.stat-value{color:var(--fg);font-weight:600}

/* Toast */
.toast{position:fixed;bottom:20px;right:20px;background:var(--panel);border:1px solid var(--border);padding:12px 16px;border-radius:6px;font-size:11px;z-index:400;transform:translateY(100px);opacity:0;transition:all .3s}
.toast.visible{transform:translateY(0);opacity:1}
.toast.success{border-color:var(--success)}

@media(max-width:768px){
  .column{min-width:280px;width:280px}
  .header .title{display:none}
}
</style>
</head>
<body>

<div class="header">
  <div class="logo">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><path d="M14 2v6h6M16 13H8M16 17H8M10 9H8"/></svg>
    PAPERS
  </div>
  <div class="title">Research Document Management</div>
  <div class="search-bar">
    <input type="text" id="search" placeholder="Search papers...">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/></svg>
  </div>
  <div class="header-actions">
    <button class="icon-btn" id="load-all" title="Reload All Papers (clears cache)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>
    </button>
    <button class="icon-btn" id="clear-cache" title="Clear Cache & Show Manifest">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
    </button>
    <button class="icon-btn" id="refs-toggle" title="References Panel">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 016.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 014 19.5v-15A2.5 2.5 0 016.5 2z"/></svg>
    </button>
    <button class="icon-btn" id="export-bib" title="Export Bibliography">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg>
    </button>
    <button class="icon-btn" id="theme-toggle" title="Toggle Theme">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/></svg>
    </button>
  </div>
</div>

<div class="scroll-container" id="scroll">
  <!-- Chains Column -->
  <div class="column" data-type="chains">
    <div class="column-header">
      <div class="column-info">
        <div class="column-dot" style="background:var(--accent)"></div>
        <div class="column-title">PAPER CHAINS</div>
        <div class="column-badge" id="chain-count">0 chains</div>
      </div>
    </div>
    <div class="column-content" id="chain-list"></div>
  </div>

  <!-- All Papers Column -->
  <div class="column" data-type="papers">
    <div class="column-header">
      <div class="column-info">
        <div class="column-dot" style="background:var(--complete)"></div>
        <div class="column-title">ALL DOCUMENTS</div>
        <div class="column-badge" id="paper-count">0 papers</div>
      </div>
    </div>
    <div class="column-content" id="paper-list"></div>
  </div>

  <!-- Content Column -->
  <div class="column content-col" data-type="content">
    <div class="column-header">
      <div class="column-info">
        <div class="column-dot" style="background:var(--prompt)"></div>
        <div class="column-title" id="doc-title">SELECT A DOCUMENT</div>
        <div class="column-badge" id="doc-type"></div>
      </div>
      <div class="column-actions">
        <button class="col-btn" id="copy-doc" title="Copy">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>
        </button>
      </div>
    </div>
    <div class="column-content" id="content-area">
      <div class="empty-state" id="empty-state">
        <div class="empty-state-icon">[PAPERS]</div>
        <p>Drop markdown files here or load from manifest</p>
        <p style="margin-top:8px;font-size:10px">Supports <code>pro-*.md</code> prompts and completions</p>
        <div class="manifest-list" id="manifest-list"></div>
      </div>
      <div class="paper-content" id="paper-content" style="display:none"></div>
    </div>
    <div class="stats-bar" id="stats-bar" style="display:none">
      <div class="stat"><span class="stat-label">Words:</span><span class="stat-value" id="word-count">0</span></div>
      <div class="stat"><span class="stat-label">Citations:</span><span class="stat-value" id="cite-count">0</span></div>
      <div class="stat"><span class="stat-label">Sections:</span><span class="stat-value" id="section-count">0</span></div>
    </div>
  </div>

  <!-- References Column -->
  <div class="column" data-type="refs" id="refs-column" style="display:flex">
    <div class="column-header">
      <div class="column-info">
        <div class="column-dot" style="background:var(--draft)"></div>
        <div class="column-title">REFERENCES</div>
        <div class="column-badge" id="ref-count">0 refs</div>
      </div>
    </div>
    <div class="column-content ref-panel" id="ref-list"></div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
const state = {
  papers: [],
  chains: {},
  currentPaper: null,
  bibliography: {},
  manifest: null
};

const STORAGE_KEY = 'republic_papers_v2';

function init() {
  loadFromStorage();
  renderSidebar();
  setupEventListeners();
  setupDragDrop();
  loadManifest();
}

async function loadManifest() {
  try {
    const res = await fetch('papers-manifest.json');
    if (!res.ok) return;
    state.manifest = await res.json();
    
    if (state.papers.length === 0) {
      renderManifestList();
    }
  } catch (e) {
    console.log('No manifest:', e);
  }
}

function renderManifestList() {
  const list = document.getElementById('manifest-list');
  if (!state.manifest || !list) return;
  
  const m = state.manifest;
  
  // Group by theme
  const byTheme = {};
  m.papers.forEach(p => {
    const theme = p.theme || 'Other';
    if (!byTheme[theme]) byTheme[theme] = [];
    byTheme[theme].push(p);
  });
  
  list.innerHTML = `
    <div style="margin-bottom:16px;padding:12px;background:var(--panel);border:1px solid var(--border);border-radius:6px">
      <div style="font-size:14px;color:var(--accent);font-weight:600;margin-bottom:8px">PAPER COLLECTION</div>
      <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;font-size:10px">
        <div><span style="color:var(--muted)">Total:</span> <strong>${m.stats.total}</strong></div>
        <div><span style="color:var(--muted)">Complete:</span> <strong style="color:var(--complete)">${m.stats.complete}</strong></div>
        <div><span style="color:var(--muted)">Pending:</span> <strong style="color:var(--draft)">${m.stats.completionOnly || 0}</strong></div>
      </div>
      <button class="manifest-btn primary" id="load-all-btn" style="width:100%;margin-top:12px;padding:10px">Load All ${m.stats.total} Papers</button>
    </div>
    
    <div style="font-size:9px;color:var(--accent);letter-spacing:.1em;margin:16px 0 8px;font-weight:600">BY THEME</div>
    ${Object.entries(byTheme).map(([theme, papers]) => `
      <div style="margin-bottom:12px">
        <div style="font-size:9px;color:var(--muted);margin-bottom:6px;padding:4px 8px;background:var(--bg2);border-radius:3px">${theme} (${papers.length})</div>
        ${papers.map(p => `
          <div class="manifest-item" onclick="loadFromManifest('${p.id}')" style="cursor:pointer">
            <div style="flex:1">
              <div class="manifest-title">${p.shortTitle}</div>
              <div class="manifest-status">
                ${p.status === 'complete' ? '<span style="color:var(--complete)">complete</span>' : 
                  p.status === 'completion-only' ? '<span style="color:var(--draft)">completion only</span>' : 
                  '<span style="color:var(--prompt)">prompt only</span>'}
              </div>
            </div>
          </div>
        `).join('')}
      </div>
    `).join('')}
  `;
  
  document.getElementById('load-all-btn')?.addEventListener('click', loadAllFromManifest);
}

async function loadFromManifest(id) {
  if (!state.manifest) return;
  const entry = state.manifest.papers.find(p => p.id === id);
  if (!entry) return;
  
  toast(`Loading ${entry.shortTitle}...`);
  
  if (entry.prompt) {
    try {
      const res = await fetch(encodeURIComponent(entry.prompt));
      if (res.ok) addPaper('prompt', entry.shortTitle, id, await res.text(), entry.theme);
    } catch (e) { console.error('Prompt load error:', e); }
  }
  
  if (entry.completion) {
    try {
      const res = await fetch(encodeURIComponent(entry.completion));
      if (res.ok) addPaper('complete', entry.title, id, await res.text(), entry.theme);
    } catch (e) { console.error('Completion load error:', e); }
  }
  
  renderUnifiedBibliography();
}
window.loadFromManifest = loadFromManifest;

async function loadAllFromManifest() {
  if (!state.manifest) return;
  
  // Clear existing papers first
  state.papers = [];
  state.chains = {};
  state.bibliography = {};
  state.currentPaper = null;
  saveToStorage();
  
  toast('Loading all papers...');
  let loaded = 0;
  
  for (const entry of state.manifest.papers) {
    await loadFromManifest(entry.id);
    loaded++;
    if (loaded % 5 === 0) toast(`Loaded ${loaded}/${state.manifest.papers.length}...`);
  }
  
  toast(`Loaded ${state.papers.length} papers from ${state.manifest.papers.length} chains`);
  renderSidebar();
}

function clearCacheAndShowManifest() {
  state.papers = [];
  state.chains = {};
  state.bibliography = {};
  state.currentPaper = null;
  localStorage.removeItem(STORAGE_KEY);
  
  document.getElementById('empty-state').style.display = 'flex';
  document.getElementById('paper-content').style.display = 'none';
  document.getElementById('stats-bar').style.display = 'none';
  
  renderSidebar();
  renderManifestList();
  toast('Cache cleared - select papers to load');
}

function loadFromStorage() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      const data = JSON.parse(saved);
      state.papers = data.papers || [];
      state.chains = data.chains || {};
      state.bibliography = data.bibliography || {};
    }
  } catch (e) {}
}

function saveToStorage() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      papers: state.papers,
      chains: state.chains,
      bibliography: state.bibliography
    }));
  } catch (e) {}
}

function renderSidebar() {
  const chainList = document.getElementById('chain-list');
  const paperList = document.getElementById('paper-list');
  
  document.getElementById('chain-count').textContent = Object.keys(state.chains).length + ' chains';
  document.getElementById('paper-count').textContent = state.papers.length + ' papers';
  
  // Render chains
  chainList.innerHTML = '';
  Object.keys(state.chains).forEach(chainId => {
    const papers = state.chains[chainId];
    if (!papers || papers.length === 0) return;
    
    const group = document.createElement('div');
    group.className = 'chain-group';
    group.innerHTML = `<div class="chain-header">${chainId.substring(0, 30).toUpperCase()}</div><div class="chain-papers"></div>`;
    
    const container = group.querySelector('.chain-papers');
    papers.forEach((paperId, i) => {
      const paper = state.papers.find(p => p.id === paperId);
      if (!paper) return;
      if (i > 0) container.innerHTML += `<div class="chain-arrow">↓</div>`;
      container.appendChild(createPaperItem(paper));
    });
    
    chainList.appendChild(group);
  });
  
  // Render all papers
  paperList.innerHTML = '';
  state.papers.forEach(paper => paperList.appendChild(createPaperItem(paper)));
}

function createPaperItem(paper) {
  const div = document.createElement('div');
  div.className = 'paper-item' + (state.currentPaper?.id === paper.id ? ' active' : '');
  div.innerHTML = `
    <div class="paper-title">${escapeHtml(paper.title)}</div>
    <div class="paper-meta">
      <span class="paper-type ${paper.type}">${paper.type}</span>
      <span>${paper.wordCount || 0} words</span>
    </div>
  `;
  div.onclick = () => loadPaper(paper.id);
  return div;
}

function loadPaper(id) {
  const paper = state.papers.find(p => p.id === id);
  if (!paper) return;
  
  state.currentPaper = paper;
  
  document.getElementById('empty-state').style.display = 'none';
  document.getElementById('paper-content').style.display = 'block';
  document.getElementById('stats-bar').style.display = 'flex';
  
  document.getElementById('doc-title').textContent = paper.title.substring(0, 50);
  document.getElementById('doc-type').textContent = paper.type;
  document.getElementById('paper-content').innerHTML = renderMarkdown(paper.content);
  
  document.getElementById('word-count').textContent = paper.wordCount || 0;
  document.getElementById('cite-count').textContent = (paper.references || []).length;
  document.getElementById('section-count').textContent = (paper.content.match(/^##\s/gm) || []).length;
  
  renderReferences(paper);
  renderSidebar();
}
window.loadPaper = loadPaper;

function renderMarkdown(text) {
  return text
    .replace(/^### (.+)$/gm, '<h3>$1</h3>')
    .replace(/^## (.+)$/gm, '<h2>$1</h2>')
    .replace(/^# \*?\*?(.+?)\*?\*?$/gm, '<h1>$1</h1>')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.+?)\*/g, '<em>$1</em>')
    .replace(/`([^`]+)`/g, '<code>$1</code>')
    .replace(/^\s*[-*]\s+(.+)$/gm, '<li>$1</li>')
    .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
    .replace(/^\d+\.\s+(.+)$/gm, '<li>$1</li>')
    .replace(/^>\s*(.+)$/gm, '<blockquote>$1</blockquote>')
    .replace(/\[(\d+)\]/g, '<span class="citation" onclick="showCitation($1)">[$1]</span>')
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>')
    .replace(/^(?!<[hublop]).+$/gm, m => m.trim() ? `<p>${m}</p>` : '')
    .replace(/\n{2,}/g, '\n');
}

function showCitation(num) {
  const ref = state.currentPaper?.references?.find(r => r.num === num);
  if (ref) toast(`[${num}] ${ref.title}`);
}
window.showCitation = showCitation;

function renderReferences(paper) {
  const refList = document.getElementById('ref-list');
  const refs = paper.references || [];
  document.getElementById('ref-count').textContent = refs.length + ' refs';
  
  // Show paper-specific refs first, then unified bibliography
  let html = '';
  
  if (refs.length) {
    html += `<div style="padding:8px 12px;background:var(--bg2);font-size:9px;color:var(--accent);letter-spacing:.1em;font-weight:600">THIS PAPER (${refs.length})</div>`;
    html += refs.map(r => `
      <div class="ref-item">
        <span class="ref-num">[${r.num}]</span>
        <span class="ref-title">${escapeHtml(r.title || 'Unknown')}</span>
        <span class="ref-url"><a href="${r.url}" target="_blank">${r.url || ''}</a></span>
      </div>
    `).join('');
  }
  
  // Add unified bibliography section
  const allRefs = Object.values(state.bibliography);
  if (allRefs.length > refs.length) {
    html += `<div style="padding:8px 12px;background:var(--bg2);font-size:9px;color:var(--accent);letter-spacing:.1em;font-weight:600;margin-top:12px">UNIFIED BIBLIOGRAPHY (${allRefs.length})</div>`;
    html += allRefs.slice(0, 20).map(r => `
      <div class="ref-item" style="opacity:0.7">
        <span class="ref-num">[${r.num}]</span>
        <span class="ref-title">${escapeHtml(r.title || 'Unknown')}</span>
      </div>
    `).join('');
    if (allRefs.length > 20) {
      html += `<div style="padding:8px;color:var(--muted);font-size:9px;text-align:center">... and ${allRefs.length - 20} more</div>`;
    }
  }
  
  refList.innerHTML = html || '<div style="padding:16px;color:var(--muted);text-align:center">No references</div>';
}

function renderUnifiedBibliography() {
  const allRefs = Object.values(state.bibliography);
  document.getElementById('ref-count').textContent = allRefs.length + ' total refs';
}

function extractCitations(content) {
  let refs = [];
  
  // Pattern 1: Markdown headers like "#### **Works cited**", "### Works cited", etc.
  const citesMatch = content.match(/#{1,4}\s*\*{0,2}Works cited\*{0,2}\s*\n([\s\S]+?)(?:\n#{1,4}\s|\n\[image|\n---|\n```|$)/i);
  if (citesMatch) {
    refs = parseNumberedRefs(citesMatch[1]);
    if (refs.length > 0) return refs;
  }
  
  // Pattern 2: Markdown headers for References/Bibliography
  const altMatch = content.match(/#{1,4}\s*\*{0,2}(?:References|Bibliography)\*{0,2}\s*\n([\s\S]+?)(?:\n#{1,4}\s|\n\[image|\n---|\n```|$)/i);
  if (altMatch) {
    refs = parseNumberedRefs(altMatch[1]);
    if (refs.length > 0) return refs;
  }
  
  // Pattern 3: Plain "REFERENCES" header (often with decorative lines like ═══)
  const plainRefMatch = content.match(/[═=]+\s*\n\s*REFERENCES\s*\n[═=]+\s*\n([\s\S]+?)(?:\n[═=]+|\n#{1,4}\s|\n\[image|$)/i);
  if (plainRefMatch) {
    refs = parseCitationKeyRefs(plainRefMatch[1]);
    if (refs.length > 0) return refs;
  }
  
  // Pattern 4: Plain "REFERENCES" without decorative lines
  const simpleRefMatch = content.match(/^REFERENCES\s*\n([\s\S]+?)(?:\n#{1,4}\s|\n\[image|\n---|$)/im);
  if (simpleRefMatch) {
    refs = parseCitationKeyRefs(simpleRefMatch[1]);
    if (refs.length > 0) return refs;
  }
  
  return refs;
}

// Parse numbered references: "1. Title, accessed Date, [link](URL)"
function parseNumberedRefs(section) {
  const refs = [];
  const lines = section.split('\n');
  
  for (const line of lines) {
    let match;
    
    // "1. Title, accessed ..., [text](URL)"
    match = line.match(/^(\d+)\.\s*(.+?),\s*accessed[^,]*,\s*\[([^\]]*)\]\((https?:\/\/[^\s\)]+)\)/);
    if (match) {
      refs.push({ num: parseInt(match[1]), title: match[2].trim(), url: match[4].trim() });
      continue;
    }
    
    // "1. Title, accessed ..., URL" (plain URL)
    match = line.match(/^(\d+)\.\s*(.+?),\s*accessed[^,]*,\s*(https?:\/\/[^\s\)]+)/);
    if (match) {
      refs.push({ num: parseInt(match[1]), title: match[2].trim(), url: match[3].trim() });
      continue;
    }
    
    // "1. Title ... [text](URL)" (no "accessed")
    match = line.match(/^(\d+)\.\s*(.+?)\s*\[([^\]]*)\]\((https?:\/\/[^\s\)]+)\)/);
    if (match) {
      refs.push({ num: parseInt(match[1]), title: match[2].trim(), url: match[4].trim() });
      continue;
    }
    
    // "1. Title ... URL" (simplest with URL)
    match = line.match(/^(\d+)\.\s*(.+?)\s+(https?:\/\/[^\s\)]+)/);
    if (match) {
      refs.push({ num: parseInt(match[1]), title: match[2].trim(), url: match[3].trim() });
      continue;
    }
    
    // Bullet point "- [1] Title ... URL"
    match = line.match(/^[-*]\s*\[?(\d+)\]?\s*(.+?)\s+(https?:\/\/[^\s\)]+)/);
    if (match) {
      refs.push({ num: parseInt(match[1]), title: match[2].trim(), url: match[3].trim() });
      continue;
    }
  }
  
  return refs;
}

// Parse citation-key references: "[author_title_year] Author, A. (Year). Title. Publisher."
function parseCitationKeyRefs(section) {
  const refs = [];
  const lines = section.split('\n');
  let num = 1;
  
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) continue;
    
    // Match [citation_key] followed by reference text
    // e.g., "[bajohr_operative_2024] Bajohr, H. (2024). Operative Ekphrasis..."
    const match = trimmed.match(/^\[([^\]]+)\]\s*(.+)/);
    if (match) {
      const citationKey = match[1];
      const refText = match[2].trim();
      refs.push({ num: num++, title: refText, url: '', key: citationKey });
    }
  }
  
  return refs;
}

function addPaper(type, title, chainId, content, theme) {
  // Check if paper already exists
  const existing = state.papers.find(p => p.chainId === chainId && p.type === type);
  if (existing) return existing;
  
  const id = 'paper_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
  const refs = extractCitations(content);
  const wordCount = content.trim().split(/\s+/).filter(w => w.length > 0).length;
  
  const paper = { id, type, title, chainId: chainId || id, content, references: refs, wordCount, theme: theme || 'Other', date: new Date().toISOString().split('T')[0] };
  
  state.papers.push(paper);
  
  if (chainId) {
    if (!state.chains[chainId]) state.chains[chainId] = [];
    const order = { prompt: 0, complete: 1, draft: 2 };
    state.chains[chainId].push(paper.id);
    state.chains[chainId].sort((a, b) => {
      const pa = state.papers.find(p => p.id === a);
      const pb = state.papers.find(p => p.id === b);
      return (order[pa?.type] || 99) - (order[pb?.type] || 99);
    });
  }
  
  refs.forEach(r => { if (!state.bibliography[r.num]) state.bibliography[r.num] = r; });
  
  saveToStorage();
  renderSidebar();
  loadPaper(id);
  return paper;
}

function setupEventListeners() {
  document.getElementById('theme-toggle').onclick = () => {
    const theme = document.body.getAttribute('data-theme') === 'light' ? '' : 'light';
    document.body.setAttribute('data-theme', theme);
    localStorage.setItem('theme', theme);
  };
  if (localStorage.getItem('theme') === 'light') document.body.setAttribute('data-theme', 'light');
  
  document.getElementById('refs-toggle').onclick = () => {
    const col = document.getElementById('refs-column');
    col.style.display = col.style.display === 'none' ? 'flex' : 'none';
  };
  
  document.getElementById('copy-doc').onclick = () => {
    if (state.currentPaper) {
      navigator.clipboard.writeText(state.currentPaper.content);
      toast('Copied to clipboard');
    }
  };
  
  document.getElementById('export-bib').onclick = () => {
    const bib = Object.values(state.bibliography);
    const text = bib.map(r => `[${r.num}] ${r.title}\n    ${r.url}`).join('\n\n');
    navigator.clipboard.writeText(text);
    toast(`Exported ${bib.length} references`);
  };
  
  document.getElementById('load-all').onclick = loadAllFromManifest;
  document.getElementById('clear-cache').onclick = clearCacheAndShowManifest;
  
  document.getElementById('search').addEventListener('input', e => {
    const q = e.target.value.toLowerCase();
    document.querySelectorAll('.paper-item').forEach(item => {
      const title = item.querySelector('.paper-title')?.textContent.toLowerCase() || '';
      item.style.display = title.includes(q) ? '' : 'none';
    });
  });
}

function setupDragDrop() {
  const area = document.getElementById('content-area');
  
  area.addEventListener('dragover', e => { e.preventDefault(); area.style.background = 'var(--bg2)'; });
  area.addEventListener('dragleave', () => { area.style.background = ''; });
  area.addEventListener('drop', async e => {
    e.preventDefault();
    area.style.background = '';
    
    const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.md'));
    for (const file of files) {
      const content = await file.text();
      const name = file.name.replace('.md', '');
      
      let type = 'complete';
      if (name.startsWith('pro-')) type = 'prompt';
      else if (name.startsWith('prompt_')) type = 'prompt';
      else if (name.startsWith('complete_')) type = 'complete';
      
      const baseName = name.replace(/^(pro-|prompt_|complete_)/, '');
      const chainId = baseName.replace(/[_:]+/g, '-').replace(/[^a-zA-Z0-9-]/g, '').toLowerCase().substring(0, 60);
      
      let title = baseName.replace(/_/g, ' ');
      const h1Match = content.match(/^#\s*\*?\*?(.+?)\*?\*?\s*$/m);
      if (h1Match) title = h1Match[1].replace(/\*\*/g, '');
      
      addPaper(type, title, chainId, content);
    }
  });
}

function toast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('visible');
  setTimeout(() => t.classList.remove('visible'), 2000);
}

function escapeHtml(str) {
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

init();
</script>
</body>
</html>
